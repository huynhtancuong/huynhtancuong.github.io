[ { "title": "Hành trình chế một cái nồi chiên không dầu điều khiển bằng điện thoại", "url": "/posts/web-interface-air-fryer/", "categories": "DIY", "tags": "DIY, Air Fryer", "date": "2023-01-07 03:10:00 +0300", "snippet": "Tại sao lại có cái này?Khoảng tầm hè năm 2022 thì mình có mua một cái nồi chiên không dầu của Trung Quốc với giá khá rẻ. Mới đầu về sử dụng khá là ngon, nhưng tầm 2 tháng sau thì nó lăn ra chết, cắm điện không thấy đèn báo hiệu lên nữa. Mình đoán có thể là do mình cắm điện liên tục không rút ra. Nhưng lý do chính chắc là do nó cùi ^^.Sơ qua về cái nồi chiên không dầuNói qua về tính năng của chiếc nồi chiên không dầu này thì cũng rất là xịn (so với giá tiền). Nhiệt độ tối đa mà nó có thể đạt đến là khoảng 200 độ C. Màn hình led 7 thanh để hiển thị nhiệt độ và thời gian. Có nút bấm cảm ứng điện dung để có thể cài đặt thời gian và nhiệt độ. Có những profile được cài đặt sẵn, ví dụ như để nướng gà, cá,… thì sẽ cần nhiệt độ và thời gian khác nhau. Nồi có dung tích phần trong là 3.5L và phần ngoài là 5L, rất to, nên nướng gà thì khá là thoải mái.Nguyên lý hoạt động của nồi chiên không dầuMuốn sửa thì trước hết phải hiểủ nguyên lý hoạt động của nó đã. Thay vì sử dụng dầu để chiên thức ăn như thông thường thì nồi chiên không dầu làm chín thức ăn bằng cách sử dụng thanh gia nhiệt kết hợp với quạt để tạo ra dòng khí nóng trong nồi, luân chuyển nhanh khắp bề mặt của thực phẩm giúp làm chín nó.Nguyên lý hoạt động của nồi chiên không dầuRồi làm sao để sửa nó?Đầu tiên là tháo nó ra thôi. Để tiếp cận với phần bo mạch điều khiển thì khá là dễ dàng, chỉ cần cái tua vít và tháo vài con ốc là xong rồi.Tổng quanBảng mạch mặt trướcBảng mạch mặt sauSau một hồi sử dụng các biện pháp nghiệp vụ thì mình đã xác định được linh kiện gây ra lỗi chính là con vi xử lý của nó. Xui vãi! Đoạn này mình sẽ phân tích một chút, tại sao lại xui. Nếu hư những linh kiện bình thường khác thì mình có thể mua cái mới về thay vào, nhưng khi đã hư vi điều khiển thì việc mua về thay thế là điều không thể. Vì bên trong vi điều khiển còn chứa chương trình để điều khiển hoạt động của nồi chiên. Nên nếu có mua được vi điều khiển mới thì mình cũng không có chương trình để nạp vào bên trong cho nó chạy. Nếu bệnh này mà gặp thợ tay non thì cũng chịu chết. Nhưng mình học cơ điện tử mà :)) kỹ sư là nghề của mình, nên mình xem đây là môt cơ hội để học thêm.Biện pháp của mình là mình sẽ lập trình một con vi điều khiển mới rồi gắn vào thay thế cho con vi điều khiển cũ. May mắn là lúc trước mình có mua một con ESP32, mãi chưa dùng đến, bây giờ thì có việc dùng rồi. Nói sơ qua về con này thì con chip này ngoài các chức năng như mấy con vi điều khiển thông thường thì nó còn hỗ trợ cả WiFi và Bluetooth nữa. Nên mình dự định sẽ thêm vào cả tích năng điều khiển bằng web thông qua WiFi luôn ^^.ESP32Bắt đầu thôi!Đầu tiên là mình sẽ tháo con vi điều khiển cũ ra khỏi bo mạch. Đoạn này mình không có máy khò chuyên dụng nên một số chân pin đã bị đứt phần chân đồng. Nhưng mình sẽ cố gắng xử lý phần này sau.Bảng mạch sau khi đã tháo vi điều khiểnSau đấy là hàn dây vào những chân của vi điều khiển cũVà đây là thành quả!Bảng mạch sau khi đã hàn dâyTiếp theo thì mình sẽ tiến hành đo và đánh dấu các chân. Mục đích là để biết được chân nào kết nối với thành phần nào trên mạch. Một số chân sẽ phụ trách việc bật tắt đèn led, chân thì dùng để bật bộ gia nhiệt, chân thì kết nối với cảm biến nhiệt độ.Đánh dấu chânBước sau đó là kết nối dây với chip điều khiển mới.Kết nối với ESP32Tiếp đó là làm quen với việc điều khiển đèn led trên bảng mạch này. Việc điều khiển này cũng không dễ dàng lắm, vì led được mắc theo dạng ma trận, nên để điều khiến được nó thì mình sẽ phải bật tắt các led tuần tự với nhau một cách nhanh chóng để đánh lừa mắt người (cái này gọi là multiplexing). Nhưng mình gặp một vấn đề đó là nếu tăng tần số quét lên thì vi điều khiển của mình không đáp ứng được (mình lập trình bằng RTOS, nên bị dính lỗi watchdog triggered, nếu ai biết hướng giải quyết thì chỉ mình với) Ban đầu mình định làm bảng điều khiển giống cũ, nhưng vì giới hạn phần cứng nên đành phải từ bỏ. Mình chuyển sang hướng điều khiển nồi chiên bằng web.Để làm được web thì bắt buộc phải dính đến HTML, CSS, Javascript. Nên mình quyết định dành hẵn một ngày để học sơ qua mấy cái này. Cộng với những tutorial trên mạng nữa thì đây là thành quả sau 2 ngày của mình. Một cái web interface có chức năng chọn nhiệt độ, thời gian và trạng thái của nồi chiên không dầu, bao gồm cả một biểu đồ về nhiệt độ đo được trong nồi cập nhật sau mỗi 2 giây.Giao diện điều khiển web của nồi chiên không dầuNhưng làm sao để kết nối với nồi chiên không dầu thông qua điện thoại hay là máy tính? Mình đã lập trình sao cho vi điều khiển trở thành một điểm kết nối Wifi. Khi điện thoại kết nối vào điểm Wifi này thì có thể mở giao diện điều khiển và tương tác với nó.Bên dưới là video demo hoạt động của nồi chiên.Mã nguồnĐây là link đến repository chứa code của nồi chiên không dầu.Kết luậnThông qua quá trình làm dự án này thì mình có cơ hội áp dụng những kiến thức mà trước đây mình học vào thực tế. Học thêm được HTML, CSS, Javascript (DOM). Ôn lại kiến thức về C. Học được cách thiết kế hệ thống. Ở đây là State Machine Design Pattern. Biết được những khó khăn trong việc lập trình led 7 thanh.Tóm lại, mình đã chuyển một cái nồi chiên giao diện nút bấm bình thường thành giao diện web. Mặc dù không thiết thực lắm khi mỗi lần đảo đồ ăn thì phải cầm lấy cái điện thoại để bấm nút thì nó mới chạy. Nhưng được cái là tự tay mình sửa thì nó vui ^^.Những cập nhật sau này…Nếu bạn là một người đọc phổ thông thì phần này không dành cho bạn đâu nha ^^.Add cache featureVì mình có một file javascript khá là nặng dùng để phục vụ việc plot graph nên mỗi lần refresh lại trang thì con ESP32 đều phải gửi lại dữ liệu này cho client. Gây nên việc quá tải cho ESP. Để giải quyết vấn đề này thì mình đã thêm vào tính năng cache. Vậy nên khi người dùng tải web lần đầu thì những file tài nguyên sẽ được lưu lại và được sử dụng cho những lần sau. Kết quả là viêc tải trang sẽ diễn ra nhanh hơn.Dưới đây là so sánh giữa việc có cache và không có cache. Như bạn có thể thấy thì việc load trang đã diễn ra nhanh hơn gấp 4-5 lần.Không có cache. Thời gian load là 2.3sCó cache. Thời gian load là 0.5sAdd OTA featureSau khi hoàn thành xong thì mình đã lắp mạch vào trong máy, nên nếu muốn cập nhật thêm tính năng và phải nạp lại code thì mình phải tháo bung nồi chiên không dầu ra để tiếp cận được với mạch. Nhưng như thế khá là mất công, nên sau khi tìm hiểu thì mình đã tìm ra giải pháp đó chính là nạp code thông qua phương thức OTA (Over the Air). Với phương pháp này thì mỗi lần nạp code thì mình không phải tháo bung mạch ra nữa. Mình làm theo hướng dẫn này, nếu bạn nào có hứng thú thì xem nha." }, { "title": "The journey of making an oil-free fryer controlled by a phone", "url": "/posts/web-interface-air-fryer-english/", "categories": "DIY", "tags": "DIY, Air Fryer, English", "date": "2023-01-07 03:10:00 +0300", "snippet": "Why have this?Around the summer of 2022, I bought a Chinese air fryer for a pretty cheap price. At first, it was quite good to use, but about 2 months later, it died, plugged in and didn’t see the indicator light on anymore. I guess it might be because I plugged it in continuously and didn’t unplug it. But the main reason is probably because it sucks ^^.Brief about the fryer without oilTalking about the features of this air fryer is also very good (compared to the price). The maximum temperature it can reach is about 200 degrees Celsius. 7 bar led display to show temperature and time. There is a capacitive touch button to be able to set the time and temperature. There are pre-installed profiles, for example, to roast chicken, fish, … will need different temperatures and times. The pot has a capacity of 3.5L inside and 5L outside, very large, so grilling chicken is quite comfortable.Working principle of oil-free fryerIf we want to fix it, we must first understand its working principle. Instead of using oil to fry food as usual, an oil-free fryer cooks food by using a heating rod combined with a fan to create a flow of hot air in the pot, rapidly circulating throughout the surface of the food and cook it.Working principle of oil-free fryerThen how to fix it?Just take it off first. To access the control board is quite easy, just need a screwdriver and remove a few screws and you’re done.OverviewFront panelBack panelAfter using various operational methods, I have determined that the main component causing the error is the control board. Oops! In this section, I will analyze a bit why it’s bad. If normal components fail, I can buy a new one to replace it, but when the control board fails, replacement is not possible. Because the control board contains the program to control the operation of the fryer. So, even if I can buy a new control board, I don’t have the program to upload into it to make it run. If an unskilled person encounters this problem, they would give up. But I learned electronics, I am an future engineer, so I see this as an opportunity to learn more.My solution is to program a new microcontroller and replace it with the old one. Fortunately, I bought an ESP32 before, never used it, now it has a job. Briefly talking about this one, this chip in addition to the functions like conventional microcontrollers, it also supports WiFi and Bluetooth. So I plan to add the web control feature via WiFi too ^^.ESP32Let’s start!First, I will remove the old microcontroller from the board. I don’t have a dedicated torch in this section, so some pins have broken copper pins. But I will try to deal with this part later.Circuit board after removing the microcontrollerThen solder the wires to the pins of the old microcontrollerAnd here is the result!Circuit board after soldering wireNext, I will proceed to use a multimeter to measure and mark the pins. The purpose is to know which pins are connected to which components on the circuit. Some pins will turn on and off the leds, others are used to turn on the heater, and the pins are connected to the temperature sensor.Proceed to mark the pin pinsThe next step is to connect the wire to the new controller chip.Connect to ESP32Next is to get familiar with controlling the leds on this circuit board. This control is also not very easy, because the leds are connected in the form of a matrix, so in order to control it, we will have to turn the leds on and off together quickly to deceive the human eye (this is called is multiplexing). But I have a problem that if I increase the scan frequency, my microcontroller cannot respond (I programmed with RTOS, so I got a watchdog triggered error, if anyone knows the solution, please tell me) I originally planned to make the same old control board, but because of hardware limitations, I had to give up. I switched to controlling the fryer by web.To make a web, it is mandatory to stick to HTML, CSS, and Javascript. So I decided to spend a whole day learning these things. Plus the online tutorials, this is my result after 2 days. A web interface that selects the temperature, time and status of the air fryer, includes a graph of the measured temperature in the fryer that updates every 2 seconds.The web interface of the air fryerBut how to connect to the air fryer via phone or computer? I have programmed the microcontroller to become a Wifi connection point. When the phone connects to this Wifi point, it is possible to open the console and interact with it.Below is a demo video of the fryer in action.Source codeHere is the link to the repository containing the code of the air fryer.ConcludeThrough the process of doing this project, I had the opportunity to apply the knowledge that I previously learned into practice. Learn more HTML, CSS, Javascript (DOM). Review knowledge about C.Learn how to design systems. Here is the State Machine Design Pattern. Know the difficulties in programming 7-segment led.In short, I have converted a normal button interface fryer into a web interface. Although it is not very practical when every time I turn the food, I have to pick up the phone to press the button for it to run. But if you can fix it yourself, it’s fun ^^.Future updates…If you are a general reader then this part is not for you ^^.Add cache featureBecause I have a fairly heavy javascript file to serve the plot graph, every time I refresh the page, the ESP32 has to send this data back to the client. Causes an overload for the ESP. To solve this problem, I added the cache feature. So when the user first downloads the web, the resource files will be saved and used for the next time. As a result, the page loads faster.Below is a comparison between cached and uncached. As you can see the page load was 4-5 times faster.No cache. Loading time is 2.3sHave cache. Loading time is 0.5sAdd OTA featureAfter finishing, I installed the circuit in the case, so if I want to update more features and have to reload the code, I have to disassemble the air fryer to access the circuit. But that was quite laborious, so after researching, I found the solution that is to load the code through the OTA (Over the Air) method. With this method, every time I load the code, I don’t have to disassemble the circuit anymore. I follow this tutorial, if you are interested, please check it out." }, { "title": "Những khái niệm chính trong hệ thống UNIX", "url": "/posts/main-concept-of-linux/", "categories": "Courses, UNIX and Linux in Infocommunication", "tags": "unix, linux, history, UNIX and Linux in Infocommunication", "date": "2022-07-18 06:10:00 +0300", "snippet": " Bài viết này là một phần của khóa học UNIX and Linux in Infocommunication được dạy bởi trường đại học ITMO. Bạn có thể xem thêm các bài viết của khóa học này trong cùng category của bài viết.Ở lớp cao nhất (top layer), các hệ thống UNIX-like1 có thể rất thuận tiện cho người dùng phổ thông và thậm chí họ có thể không biết mình đang sử dụng loại hệ điều hành này. Ví dụ, hiện tại các hệ điều hành được sử dụng phổ biến nhất là hệ thống Android dựa trên Linux và hệ thống Apple dựa trên UNIX, trong đó người dùng chỉ nhìn thấy giao diện đồ họa thân thiện với người dùng. Nhưng những người mới bắt đầu mới bắt đầu tìm hiểu các hệ thống UNIX-like để có thể quản trị hệ thống hoặc phát triển phần mềm đôi khi phàn nàn về sự phức tạp của nó. Nhưng đừng sợ! Thực ra những hệ thống như vậy dựa trên những khái niệm khá đơn giản. Chỉ có bốn điều mà bạn cần biết để sử dụng thoải mái với bất kỳ hệ thống UNIX-like nào: User (Người dùng) File (Tệp tin) Process (Tiến trình) Terminal (Cửa sổ dòng lệnh)User (Người dùng)Khái niệm “User” không được người dùng hiện đại biết đến nhiều chỉ vì hiện nay chúng ta có rất nhiều máy tính cá nhân. UNIX được tạo ra vào thời điểm mà máy tính rất hiếm và đắt tiền và một máy tính được nhiều người sử dụng. Do đó, ngay từ đầu, UNIX đã có các chính sách bảo mật mạnh mẽ và các hạn chế về quyền đối với người dùng. Và giờ đây, trên các hệ thống UNIX-like, chúng ta có rất nhiều user (người dùng) và group (nhóm), ngay cả khi bị ẩn bởi hệ thống autologin. Và hầu hết trong số họ được gọi là người dùng giả (pseudo-users), cần thiết để khởi động các dịch vụ hệ thống. Như chúng ta sẽ thấy ở phần sau, sự tồn tại của chúng được yêu cầu bởi kiến trúc hệ thống, vì nó dựa trên quyền của người dùng và nhóm mà hệ thống được xây dựng để kiểm soát quyền truy cập vào tài nguyên hệ thống (processes and files).Người dùng thông thường có thể đăng nhập bằng tên người dùng và mật khẩu và tương tác với các ứng dụng được cài đặt trên hệ thống. Mỗi người dùng chỉ có toàn quyền (full permissions) trong thư mục chính của họ (home directory) và quyền truy cập hạn chế vào các file và thư mục bên ngoài thư mục đó. Điều này là dễ hiểu - người dùng thông thường không thể phá hủy bất cứ thứ gì trên hệ thống vì họ không có quyền đó. Hơn nữa, họ không thể xem thư mục chính của người dùng khác hoặc các file và thư mục hệ thống được bảo vệ. Để thực hiện các tác vụ quản trị hệ thống, hệ thống có một superuser đặc biệt (thường được gọi là “root”) với các quyền bổ sung. Ở cấp hệ thống, mỗi user hoặc group được biểu thị như một số nguyên: User Identifier (UID) Group Identifier (GID)File (Tệp tin)File là thứ quan trọng tiếp theo đối với các hệ thống UNIX-like. Hầu hết tất cả các tài nguyên hệ thống như file, bao gồm các device và các process trên một số hệ thống. Và các khái niệm cơ bản vẫn giống nhau kể từ đầu kỷ nguyên UNIX. Chúng ta có một hệ thống file phân cấp với một thư mục gốc duy nhất. Tất cả các tài nguyên, bao gồm hệ thống file hiện có trên device hoặc ở cloud bên ngoài, được đính kèm vào hệ thống file này trong các thư mục riêng biệt - thao tác này được gọi là “mount”. Mặt khác, bạn có thể truy cập một thiết bị (thực hoặc ảo) dưới dạng một byte stream và làm việc với nó như một file thông thường. Tất cả các file và thư mục đều thuộc sở hữu của user (thực hoặc giả) và các group, và quyền truy cập đọc, ghi và thực thi chúng được kiểm soát bởi các quyền.Process (Tiến trình)Process là một chương trình được khởi chạy từ một file thực thi. Mỗi process thuộc về một người dùng và một nhóm. Mối quan hệ giữa chủ sở hữu của các process và tài nguyên xác định quyền truy cập theo quyền tài nguyên. Tất cả các process sống trong một hệ thống phân cấp dựa trên các mối quan hệ cha-con. Có một quá trình ban đầu trên hệ thống được gọi là ‘init’ được bắt đầu khi khởi động. Tất cả các dịch vụ hệ thống được bắt đầu từ quá trình ban đầu này. Về cơ bản, có hai loại process trong Linux: Foreground process Background processForeground process (còn được gọi là interactive process) - những process này được khởi tạo và kiểm soát thông qua một terminal. Nói cách khác, phải có một người dùng kết nối với hệ thống để bắt đầu các quá trình đó; chúng không tự động khởi động như một phần của các function/service trong hệ thống. Các process foreground interative (tiến trình tương tác) phải được kết nối vào một phiên terminal (terminal session).Background process (còn được gọi là các non-interactive/automatic processes) - là các process không được kết nối với phiên terminal (terminal session); chúng không yêu cầu bất kỳ input nào từ người dùng. Các service của hệ thống luôn là các background process.Terminal (Dòng lệnh)Vào thời điểm tạo ra UNIX, một thiết bị TTY (teletype) (ban đầu được phát triển vào thế kỷ 19), là kênh giao tiếp chính giữa người dùng và máy tính. Đó là một giao diện rất đơn giản hoạt động với một dòng byte được mã hóa theo bộ ký tự ASCII. Kết nối được thực hiện thông qua serial interface (giao thức serial) (vd: RS232) có tốc độ kết nối cố định. Giao thức này vẫn là giao diện người dùng chính cho các hệ thống UNIX-like. Việc triển khai từng hình thức tương tác người dùng mới, chẳng hạn như device terminal toàn màn hình, hệ thống đồ họa và kết nối mạng, tất cả đều bắt đầu bằng việc triển khai giao diện dòng lệnh TTY đơn giản. Hơn nữa, sự trừu tượng hóa giao thức này cung cấp cho chúng ta một cơ chế rất mạnh mẽ và linh hoạt để giao tiếp giữa các chương trình, có thể không có sự can thiệp của con người.Reverse footnotes Unix-like là từ dùng để chỉ các hệ thống có kiến trúc giống với Unix nhưng không phải Unix. &#8617; " }, { "title": "Những thành phần trong hệ thống UNIX", "url": "/posts/components-of-linux/", "categories": "Courses, UNIX and Linux in Infocommunication", "tags": "unix, linux, history, UNIX and Linux in Infocommunication", "date": "2022-07-18 06:10:00 +0300", "snippet": " Bài viết này là một phần của khóa học UNIX and Linux in Infocommunication được dạy bởi trường đại học ITMO. Bạn có thể xem thêm các bài viết của khóa học này trong cùng category của bài viết.Triết lý thiết kế chính được sử dụng trong hệ thống UNIX-like là nguyên tắc “KISS”. Từ KISS là viết tắt của “keep it stupid simple” hay “keep it short and simple”. Là một nguyên tắt được dùng bởi Hải quân Hoa Kỳ (U.S. Navy) vào năm 1960. Nguyên tắt KISS nói rằng hầu hết các hệ thống hoạt động tốt nhất nếu chúng là những hệ thống đơn giản thay vì phức tạp. Do đó, sự đơn giản phải là mục tiêu chính (key goal) và ta phải tránh những sự phức tạp không cần thiết.Ngay từ những ngày đầu của kỷ nguyên UNIX, nó đã có tính mô-đun rất linh hoạt. Các thành phần cơ bản của một hệ thống UNIX-like chỉ bao gồm: Kernel Shell Libraries UtilitiesKernel - Hạt nhân hệ điều hànhKernel là một tập mã lệnh của hệ điều hành được load vào bộ nhớ RAM của máy tính và thực thi đầu tiên. Chương trình này sau đó khởi chạy tất cả các process khác trên hệ thống, xử lý các tương tác giữa các tài nguyên hệ thống và vẫn tồn tại trong khi máy tính của chúng ta chạy. Kernel được chạy với đặc quyền cao nhất và có khả năng truy cập vào mọi tài nguyên của hệ thống. Tất cả các process nào hoạt động trong user space1 thì tương tác với các tài nguyên hệ thống bằng cách gửi những yêu cầu đến kernel thông qua một chức năng phần mềm đặc biệt gọi là “system calls”2. Và kernel phải xử lý những yêu cầu đó dựa theo quyền (permission) giữa process và tài nguyên hệ thống.Shell - Cửa sổ dòng lệnh UNIX Shell đầu tiên được giới thiệu bởi Ken Thompson vào năm 1971Shell là thứ quan trọng nhất hỗ trợ cho việc giao tiếp giữa người dùng, chương trình và kernel. Shell chỉ là một chương trình được khởi chạy khi người dùng đăng nhập và nó lắng nghe (listen) các sự kiện input (thường là từ bàn phím) và hiển thị kết quả của các lệnh ra output (thường là màn hình).“Bourne shell” là một trình shell nổi tiếng, được phát triển bởi Stephen Bourne tại Bell Labs vào năm 1979 và trở thành trình shell mặc định cho UNIX version 7 được phát hành cho các trưởng đại học và cao đẳng. Hỗ trợ biến môi trường (enviroment variables), chuyển hướng luồng input/output, program pipes và khả năng lập trình mạnh mẽ. Tất cả các shell ngày nay (không chỉ riêng các shell UNIX) được thừa hưởng các tính năng này từ Bourne shell.Shell là một thứ chất kết dính hiệu quả để liên kết các chương trình tiện ích trong một hệ điều hành đa nhiệm. Các chương trình tiện ích này đã được phát triển từ rất sớm kể từ sự ra đời của UNIX. Chúng là những công cụ để chúng ta có thể làm việc với users, groups, files, và processes. Và vì UNIX ban đầu được phát triển để tự động hóa các công việc của bộ phận cấp bằng sáng chế tại Bell Labs nên nó có một bộ công cụ phong phú và mạnh mẽ để xử lý text file và text stream.Design pattern phổ biến nhất cho các phần mềm tiện ích của UNIX là bộ lọc (filter) giữa standard input và standard output. Vậy nên nhiều phần mềm tiện ích của UNIX có thể kết hợp thành một cái gọi là program pipeline (đường ống phần mềm) và ta có thể sử dụng program pipeline trong shell để giao tiếp giữa các chương trình với nhau. Mỗi chương trình tiện ích riêng lẻ có thể rất đơn giản, nhưng khi kết hợp chúng cùng nhau thì ta có thể tạo ra một hợp chất mạnh mẽ chỉ trên một dòng lệnh duy nhất. Doug Mcllroy là trưởng của Bell Labs Computing Sciences Research Center, và cũng là người phát minh ra UNIX pipe, đã mô tả triết học của UNIX như sau: “Write programs that do one thing and do it well.Write programs to work together.Write programs to handle text streams, because that is a universal interface.”Hiện tại, các chương trình tiện ích được sử dụng phổ biến nhất chính là các tiện ích của dự án GNU, chúng được tạo ra sau khi UNIX được thương mại hóa. Trong hầu hết các trường hợp, những tiện ích của dự án GNU mạnh mẽ và nhiều thông số phức tạp hơn các tiện ích của phiên bản UNIX được thương mại. Trên các thiết bị nhúng có bộ nhớ nhỏ. Người ta sử dụng “Busybox” để đóng gói các tiện ích lại thành một tệp thực thi duy nhất thay vì để chúng nằm riêng lẻ. Điều này giúp tiết kiệm dung lượng lưu trữ.LibrariesTất cả các tiện ích (utilities) và shell được xây dựng nằm phía trên các software libraries. Những thư viện này có thể là thư viện liên kết động (shared libraries) hoặc là thư viện tĩnh (static).Trong trường hợp thư viện liên kết động (shared libraries), chúng ta dễ dàng hơn trong việc cập nhật và sửa đổi các thư viện, đồng thời do các ứng dụng sử dụng chung thư viện này nên ta có thể tiết kiệm được dung lượng bộ nhớ hơn là khi dùng thư viện tĩnh.Trong trường hợp thư viện liên kết tĩnh (static libraries), chúng ta có một chương trình khép kín và ít phụ thuộc vào cấu hình của hệ thống và có thể độc lập với các platform khác nhau hơn.Chúng ta có thể sử dụng các thư viện liên kết động được phát hành bởi giấy phép GPL để viết các ứng dụng động quyền, nhưng ta không thể sử dụng các thư viện liên kết tĩnh được pháp hành bởi giấy phép GPL để làm điều tương tự.Reverse Footnotes không gian người dùng. Một hệ điều hành máy tính hiện đại thường tách bộ nhớ ảo thành không gian người dùng và không gian hạt nhân. Về cơ bản, sự tách biệt này nhằm cung cấp khả năng bảo vệ bộ nhớ và bảo vệ phần cứng khỏi hành vi phần mềm độc hại hoặc sai lầm. &#8617; Trong máy tính, một lời gọi hệ thống (system calls) là việc một chương trình máy tính yêu cầu một dịch vụ từ nhân của hệ điều hành mà nó được thực thi. Điều này có thể bao gồm các dịch vụ liên quan đến phần cứng, tạo và thực thi các tiến trình mới, giao tiếp với các dịch vụ nhân tích hợp như lập lịch xử lý. &#8617; " }, { "title": "Tính mở và miễn phí của Linux", "url": "/posts/linux-open-and-free/", "categories": "Courses, UNIX and Linux in Infocommunication", "tags": "unix, linux. history", "date": "2022-07-15 09:30:00 +0300", "snippet": "Ban đầu, khi các dự án R&amp;D trên máy tính hầu hết chỉ là nghiên cứu của trường đại học, chúng là nguồn mở và miễn phí như một kết quả nghiên cứu khoa học thông thường. Ngoài ra, các nhà khoa học rất quan tâm đến việc phổ biến rộng rãi kết quả này, bởi vì giá trị của họ, danh tiếng của họ phụ thuộc trực tiếp vào sự nổi bật của công trình khoa học của họ. Thương mại hóa đã thay đổi thế giới này sang mô hình khép kín và trả phí. Không hoàn toàn khép kín, bởi vì tiêu chuẩn hóa là rất quan trọng đối với các cơ quan chính phủ và người tiêu dùng doanh nghiệp để bảo vệ các khoản đầu tư và ngăn chặn việc độc quyền của các nhà cung cấp. Do đó, nhiều tiêu chuẩn mở đã được tạo ra bởi các ủy ban và tổ chức: POSIX, ANSI, ISO. Và sự cởi mở là một vũ khí nghiêm trọng trong cạnh tranh kinh doanh. Ví dụ, một số công ty nổi tiếng. bao gồm Bull, DEC, IBM, HP, Hitachi, Philips, Siemens và những công ty khác, đã thành lập Quỹ Phần mềm Mở (OSF) để chống lại SUN và AT&amp;T trong cái gọi là “Unix War”. Hệ thống con POSIX (thực ra chỉ là mô tả của các tiêu chuẩn hệ thống giống UNIX) được đưa vào Microsoft Windows NT vì vào những năm 1980, chính phủ liên bang Hoa Kỳ yêu cầu khả năng tương thích với tiêu chuẩn mở này cho các hợp đồng chính phủ.Tính cởi mở này rất quan trọng vì chúng ta nhận được nhiều hệ thống tương thích hơn từ các nhà cung cấp khác nhau, lý tưởng là không có các tính năng không có giấy tờ. Kết quả là chúng ta có cơ sở hạ tầng máy tính với hiệu suất cao hơn và chi phí để sở hữu thấp hơn. Nhưng đối với một số người, đặc biệt là trong giới khoa học, điều này là chưa đủ. Và vào năm 1985, Richard Stallman từ MIT đã xuất bản Tuyên ngôn GNU, nơi ông công bố Dự án GNU. Mục tiêu chính của dự án này là tạo ra một HĐH giống UNIX với đầy đủ các tiện ích UNIX từ các phần mềm hoàn toàn miễn phí. Quỹ Phần mềm Tự do (FSF) được thành lập để hỗ trợ các hoạt động này.Nhưng sự tự do này trong thế giới máy tính là gì và nó khác với sự cởi mở như thế nào? Sự khác biệt này được mô tả chính xác nhất trong giấy phép. Trong thế giới độc quyền, được sử dụng rộng rãi nhất là cái gọi là giấy phép bản quyền, thường hạn chế một số quyền của người dùng. Ngay cả khi có quyền truy cập hợp pháp vào mã nguồn, người giữ bản quyền vẫn có thể kiện người tiêu dùng, như chúng ta đã thấy trong các vụ kiện USL chống lại BSD hoặc SCO chống lại IBM. Ngược lại, thế giới phần mềm miễn phí sử dụng giấy phép copyleft. Giấy phép cho phép nổi tiếng nhất dành cho phần mềm miễn phí được xuất bản vào cuối những năm 1980. Hai trong số đó, có tên là BSD và MIT - các tổ chức giáo dục, nơi mà chúng được tạo ra - trông gần như giống nhau và cho chúng ta các quyền cơ bản sau: Quyền tự do chạy chương trình theo ý muốn, cho bất kỳ mục đích nào (quyền tự do 0). Quyền tự do nghiên cứu cách chương trình hoạt động và thay đổi nó để nó hoạt động tính toán của bạn như bạn muốn (quyền tự do 1). Quyền truy cập vào mã nguồn là điều kiện tiên quyết cho việc này. Quyền tự do phân phối lại các bản sao để bạn có thể giúp đỡ người khác (quyền tự do 2). Quyền tự do phân phối các bản sao của các phiên bản đã sửa đổi của bạn cho người khác (quyền tự do 3). Bằng cách này, bạn có thể cho cả cộng đồng cơ hội được hưởng lợi từ những thay đổi của bạn. Quyền truy cập vào mã nguồn là điều kiện tiên quyết cho việc này.Các dự án nổi tiếng nhất được phát hành theo các giấy phép này là BSD Unix và hệ thống đồ họa MIT X-Window. Các giấy phép như vậy không hạn chế việc sử dụng các dự án phái sinh khép kín và quyền sở hữu của chúng. Để tránh điều này, Giấy phép Công cộng GNU (GNU GPL hoặc GPL) đã được phát triển. Một giới hạn quan trọng được thêm vào các quyền tự do cơ bản của giấy phép này (chạy, tìm hiểu, chia sẻ và sửa đổi phần mềm) là giới hạn đóng cửa. Mọi tác phẩm phái sinh phải được phân phối theo các điều khoản cấp phép giống nhau hoặc tương đương. Và sự khác biệt chính giữa phần mềm đặc tả mở và phần mềm thực sự miễn phí là chúng ta thực sự có một tiêu chuẩn de facto, không phải một tiêu chuẩn de jure. Trong phần mềm nguồn mở và miễn phí, chúng tôi có các triển khai tham chiếu đang hoạt động có thể được sử dụng làm cơ sở cho việc phát triển và thử nghiệm chéo trong tương lai. Thật thú vị, nhưng giấy phép này không hoàn toàn hạn chế việc tạo ra các ứng dụng đóng độc quyền bằng cách sử dụng phần mềm được cấp phép GPL. Ví dụ, nhân hệ điều hành hoặc các thư viện được chia sẻ, đơn giản vì chúng không được bao gồm trực tiếp trong mã ứng dụng độc quyền. Giờ đây, chúng tôi có nhiều giấy phép mã nguồn mở và miễn phí được phê duyệt bởi Sáng kiến Nguồn mở. Một thách thức khác đối với thế giới tự do và mở là các vụ kiện về bằng sáng chế. Ví dụ, vào năm 2007, Microsoft đã đe dọa sẽ kiện các công ty Linux như Red Hat vì vi phạm bằng sáng chế. Để giải quyết vấn đề này, giấy phép GPLv3 đã được tạo ra, cùng với một số hoạt động như Mạng Sáng chế Mở (OIN), có nhóm bằng sáng chế bảo vệ và cộng đồng không xâm phạm bằng sáng chế cho phép tự do hành động trong Linux." }, { "title": "Lịch sử ra đời của Linux", "url": "/posts/history-of-linux/", "categories": "Courses, UNIX and Linux in Infocommunication", "tags": "unix, linux. history", "date": "2022-07-15 09:30:00 +0300", "snippet": " Bài viết này là một phần của khóa học UNIX and Linux in Infocommunication được dạy bởi trường đại học ITMO. Bạn có thể xem thêm các bài viết của khóa học này trong cùng category của bài viết.Khi nói về lịch sử của Linux, chúng ta có thể nhớ lại một câu nói nổi tiếng. We make our inventions stand on the shoulders of giants.Tạm dịch là “Chúng tôi sáng chế ra những phát minh trên vai của những người khổng lồ.” Đây là một câu nói ẩn dụ có ý nghĩa là sử dụng sự hiểu biết của các nhà tư tưởng lớn đã đi trước để đạt được những tiến bộ hơn về trí tuệ. Nhưng chúng ta cần phải hiểu rằng nhiều trong số những người khổng lồ đó đã ngã xuống. Nhưng sự ngã xuống đó có thể là một bài học tốt cho những developer kế tiếp.Dự án MULTICSMột trong những kẻ khổng lồ đó chính là dự án MULTICS. Dự án MULTICS bắt đầu phát triển vào năm 1965 như là một dự án nghiên cứu bởi Đại học MIT, General Electric và phòng thí nghiệm Bell Labs với mục đích là tạo ra một hệ điều hành phân bổ thời gian (time-sharing), đa tiến trình (multiprocessing) và phục vụ được đồng thời nhiều người dùng (multiuser interactive).Sau vài năm phát triển, sự nhiệt huyết của những nhà phát triển trong dự án càng ngày càng giảm bởi vì hệ thống mà nhóm này phát triển đã trở nên ngày càng phức tạp và nhóm này ngày càng không tin rằng dự án này có thể hoàn thành. Cuối cùng, Bell Labs kết thúc dự án vào năm 1969, nhưng bù lại thì những người tham gia vào dự án đã có được rất nhiều kinh nghiệm từ nó. Một trong số bọn họ là Ken Thompson và Dennis Ritchie - nhà sáng lập của hệ điều hành UNIX.Sự ra đời của hệ điều hành UNIXĐiều này có vẻ khó tin, nhưng sự ra đời của hệ điều hành UNIX liên quan chặt chẽ đến trò chơi điện tử. Đầu năm 1969, khi Ken Thompson phát hiện ra một cái máy tính PDP-7 nằm giữa một đống lộn xộn trong một góc của phòng thí nghiệm và ông muốn sử dụng nó để chơi trò “Space Travel”. Nhưng điều này đồng nghĩa với việc ông phải viết một hệ điều hành để chạy nó. Và Ken Thompson đã làm điều đó, vào giữa đêm ngày 1 tháng 1 năm 1970, kỷ nguyên của Unix đã bắt đầu. Kể từ thời khắc này, tất cả các đồng hồ của các hệ thống Unix-like đều bắt đầu đếm ngược, bao gồm cả chiếc điện thoại di động của bạn. Ban đầu, hệ điều hành chỉ là một hệ điều hành đơn tiến trình, được viết bằng ngôn ngữ Assembly và được gọi là UNICS như là một sự đối lập với sự phức tạp của MULTICS.Sau đó, team của Ken Thompson và Dennis Ritchie đã nhận được một chiếc máy tính DEV PDP11 mới để phát triển một hệ thống xử lý văn bản cho bộ phận cấp bằng sáng chế của Bell Labs. Trong 3 tháng đầu, chiếc máy tính mới này chỉ nằm trong một góc phòng chỉ vì nó cần phải chờ một cái ổ cứng đang được ship đến thì mới có thể chạy được. Để không lãng phí thời gian, đội ngũ trong phòng thí nghiệm dùng thời gian này để chọn một ngôn ngữ lập trình mới, vì chiếc máy tính này có một kiến trúc hoàn toàn mới nên họ không thể tận dụng lại hệ điều hành cũ đã viết cho chiếc PDP7.Ngôn ngữ lập trình được chọn là một ngôn ngữ có tên là BCPL. Đây là một ngôn ngữ lập trình bậc cao, chú trọng vào tính di động. Phần lớn thành phần của ngôn ngữ này được viết bởi chính ngôn ngữ đó, và chỉ một phần nhỏ là được viết bởi ngôn ngữ Assembly. Để cho chiếc máy tính mới có thể chạy được, chỉ 1/5 trình compiler là phải được viết lại nên chỉ tốn khoảng 2-5 tháng để phát triển.Sau đó, Ken Thompson dựa trên BCPL để phát triển một ngôn ngữ mới - ngôn ngữ B. Vào năm 1971, Dennis Ritchie bắt đầu cải tiến ngôn ngữ B, kết quả là một ngôn ngữ mới mang tên ngôn ngữ C. Tiếp đó vào năm 1973, nhân kernel của UNIX đã được viết lại bằng ngôn ngữ C để theo đuổi tính di động - phần lớn thành phần của ngôn ngữ không phụ thuộc vào kiến trúc của máy tính (machine independent language) Machine Independent language - là một ngôn ngữ mà có thể chạy trên bất kỳ máy tính nào. Một ví dụ chính là Java, vì máy ảo Java (Java virtual machine) nhận code đã được biên dịch của ứng dụng Java và thực thi nó. Chứ code của ứng dụng Java không thể chạy trực tiếp trên máy tính.Berkeley Software Distribution (BSD)Mã nguồn của hệ điều hành sau đó được phân phối giữa các trường đại học với nhau (với một khoảng phí không đáng kể), và trở nên phổ biến vào những năm 80. Phần lớn các nhà phát triển hệ thống máy tính mới kể từ thời kỳ này đều sử dụng UNIX như là một nền tảng cho ứng dụng của họ. Nổi tiếng nhất phải kể đến chính là Berkeley Software Distribution (BSD) được phát triển bởi Đại học California và dựa trên Unix phiên bản thứ 6 với copyleft license1 của chính nó. Và hầu hết các nhà cung cấp phần cứng của những năm 1980 đã sử dụng BSD làm hệ điều hành cơ bản cho các máy tính mới của họ.UNIX không phải là một phần quan trọng trong hoạt động kinh doanh của Bell Labs nên việc đó tạm thời chưa có vấn đề gì. Nhưng vào những năm 1980, phòng thí nghiệm Bell Labs của AT&amp;T đã tách ra thành nhiều công ty nhỏ hơn do một sự kiện chống lại AT&amp;T. Một trong số đó là công ty UNIX System Laboratories và phát triển một tiêu chuẩn UNIX System V mới. Vì UNIX là lĩnh vực kinh doanh chính của công ty này nên họ đã nhanh chóng đưa tiêu chuẩn mới này ra thị trường. Và điều đó chính là nguyên nhân của cuộc chiến UNIX chống lại những nhà phát triển phi thương mại bao gồm cả BSD.Việc thương mại hóa UNIX và việc chuyển từ mô hình phát triển và phân phối mở sang mô hình phát triển và phân phối kín đã dẫn đến sự ra đời của một hệ thống thay thế UNIX - dự án GNU.Sự thay thế của UNIX - dự án GNUGNU là cái gì? Nếu bạn tìm trên Google thì sẽ ra hình ảnh của những con Linh dương đầu bò. Nhưng nó cũng là viết tắt của một cái tên theo dạng đệ quy “GNU is Not Unix”. Dự án này được thành lập bởi Richard Stallman vào năm 1978 tại Đại học MIT. Dự án GNU là một sáng kiến để phát triển một bộ sưu tập đồ sộ các phần mềm miễn phí. Mục tiêu đầu tiên của dự án là phát triển một bộ phần mềm tương tự như bộ phần mềm tiện ích của UNIX.Vào năm 1991, một sinh viên Phần Lan là Linus Torvalds đã tự tạo ra nhân kernel hệ điều hành của riêng anh ta với mục đích ban đầu là chỉ cho vui. Nhân kernel này tương thích với hệ điều hành UNIX và được gọi là Linux.Sau đó, nhân Linux kernel này kết hợp với bộ phần mềm tiện ích từ dự án GNU, đóng vai trò là cơ sở để tạo ra một hệ điều hành hoàn chỉnh, có khả năng ngang với hệ điều hành Unix và thậm chí còn vượt trội hơn.Reverse Footnotes Copyleft (còn gọi là bản quyền bên trái) là một cách chơi chữ đúp từ chữ copyright trong tiếng Anh có nghĩa là bản quyền, trong đó chữ left (bên trái) phản nghĩa với nghĩa của từ right (bên phải), mặc dù chữ “right” copyright có nghĩa là “quyền lợi” chứ không mang nghĩa “bên phải”. Đồng thời copyleft còn có thể hiểu là copy left (nghĩa là bản sao cho dùng, bản sao được phép dùng). Copyleft mô tả cách sử dụng luật bản quyền để loại bỏ tất cả các hạn chế về phân phối bản sao và các phiên bản tác phẩm đã được chỉnh sửa cho mọi người và yêu cầu phải bảo lưu quyền tự do như vậy trong các phiên bản chỉnh sửa. &#8617; " }, { "title": "Tony Buổi Sáng: chuyện ở Trung Đông", "url": "/posts/tony-buoi-sang-chuyen-o-trung-dong/", "categories": "Sách, Tony Buổi Sáng", "tags": "sách, tony buổi sáng, blog tiếng việt", "date": "2022-07-13 11:37:00 +0300", "snippet": "Trong phần này, tác giả Tony kể về một câu chuyện, một hiện tượng xảy ra ở các nước Trung Đông. Câu chuyện đó là sự thay đổi về cách làm giàu của con người ở các nước này. Từ việc một quốc gia chỉ biết múc dầu tự nhiên lên để bán kiếm tiền, cho đến một quốc gia đầu tư vào du lịch, vận tải.Sự thay đổi này đến từ việc những thế hệ trẻ của nước này sau khi đi du học ở các nước phương Tây về đều nhận ra cách thức kiếm tiền này là một phương pháp không lâu dài. Vì thế họ đã lèo lái đất nước pháp triển theo một cách bền vững hơn.Tại sao con người mới là tài nguyên quan trọng nhất?Câu trả lời cho câu hỏi này có thể bắt đầu từ việc hỏi một câu hỏi khác. Tại sao những nước có ít tài nguyên như Nhật Bản lại có thể phát triển hơn những nước có nhiều tài nguyên hơn? Câu trả lời có thể là do sự thành công này không phụ thuộc vào yếu tố tài nguyên, mà có thể là một yếu tố nào đó khác. Yếu tố chính tạo nên sự thành công ở đây chính là yếu tố con người. Không có dòng máu của ai, của dân tộc nào là đẳng cấp, tất cả do mỗi cá nhân nỗ lực mà tạo nên đẳng cấp của riêng mình. Một đứa trẻ mồ côi trong trại mồ côi ở Việt Nam cũng có thể trở thành một bộ trưởng ở Đức. Cũng không có người dở, chỉ có người lười học tập, lười lao động và biến thành người dở. - trích Tony Buổi SángTài sản là gì? Đầu tư thế nào mới là đúng cách?Theo tác giả, có bốn loại tài sản đó là: vốn sống nhân cách thể lực trí lựcVà tất cả những thứ còn lại đều là phương tiện.Vì suy cho cùng, thứ mà chúng ta gọi là bằng cấp cũng chỉ là một tờ giấy chứng nhận rằng trong một khoảng thời gian nào đó, chúng ta đã vượt qua một bài thi sát hạch. Biệt thự, chung cư cũng chỉ là phương tiện trú ngụ (giống như hang đá ngày xưa), siêu xe (xe hơi, xe máy cũng như xe ngựa cách đây mấy trăm năm) hay tiền bạc (đô la vàng bạc cũng chỉ là phương tiện trao đổi hàng hóa) giống vỏ sò cách đây 2000 năm.Chúng ta thường nhầm lẫn giữa tài sản và phương tiện. Cách đây 2000 năm, một người đầu tư cho chiếc hang của họ trở nên thật lung linh và đi nói với mọi người rằng họ đang để dành cho con cháu. Vậy thử hỏi sau 2000 năm, chiếc hang lung linh đó có còn giá trị gì nữa không? - không. Ở trường hợp ngược lại, nếu 2000 năm trước người đó đầu tư cho một nhân cách lấp lánh, một trí tuệ lung linh thì ở thời điểm 2000 năm sau nó vẫn còn lưu giữ lại giá trị của nó và trở thành một thứ và con cháu có thể tự hào.Kết luậnChúng ta phải nên đầu tư bản thân, đầu tư vào tài sản chứ không phải là vào phương tiện. Để những gì chúng ta đầu tư vẫn giữ được giá trị của nó chứ không mất đi theo thời gian.Học học học, làm làm làm, kỷ luật kỷ luật kỷ luật" }, { "title": "I made my own custom CAN node!", "url": "/posts/olimp-can-module/", "categories": "Projects, OLIMP", "tags": "stm32, can bus", "date": "2022-07-10 10:05:00 +0300", "snippet": "In this post, I’m going to show you about my CAN module and short explanation about what is CAN, and problem solved by CAN. Now let’s start with the problem which lead to the invention of CAN.Problem of Automobile’s developmentA long time a go, in the automobile industry, people start to make smarter cars with more and more features. A long with that, the car must contain more electrical components, that lead to the result that there are more and more wires in the car to connect these electrical components together. The more wire, the more complicated structure, the harder for the worker to detect and repair the car if there are any problems.To fix this problem, in 1983, a company named Bosch started to develop CAN bus. Which allow an easier communication protocol between electrical components.What is CAN bus?A Controller Area Network (CAN bus) is a robust vehicle bus standard designed to allow microcontrollers and devices to communicate with each other’s applications without a host computer. It is a message-based protocol, designed originally to multiplex electrical wiring within automobiles to save on copper, but it can also be used in many other contexts. For each device, the date in a frame is transmitted serially but in such a way that if more than one device transmits at the same time, the highest priority device can continue while the other back off. Frames are received by all devices, including by the transmitting device.Versions of CAN bus Name Description CAN 2.0A Use 11 bits for identifier, smaller amount of nodes in bus CAN 2.0B Use 29 bits for identifier, bigger amount of nodes in bus CANFD Use different frame format, allows different data length, compatible with CAN 2.0 Applications of CAN bus Passenger vehicles, trucks, buses (combustion vehicles and electric vehicles) Agricultural equipment Electronic equipment for aviation and navigation Industrial automation and mechanical control Elevators, escalators Building automation Medical instruments and equipment Pedelecs Model railways/railroads Ships and other maritime applications Lighting control systems 3D PrintersPhysical organization of CAN bus CAN is a multi-master serial bus standard for connecting electronic control unit (ECUs) also known as nodes. Two or more nodes required on the CAN network to communicate. All nodes are connected to each other through a physically conventional two wire bus. The wires are a twisted pair with a 120 $\\Omega$ which match with the characteristic impedance of the transmission line to avoid reflection.A CAN Node consists of: CAN Controller CAN Transceiver MicrocontrollerSome microcontrollers like ESP32, STM32xxx have a built-in CAN Controller, so we just need to have additionally a CAN Transceiver to complete the node. But in some microcontroller like Arduino UNO R3 don’t have a built-in CAN Controller, to complete the CAN node, we have to add external CAN Controller and CAN Transceiver.Because STM32 have built-in CAN Controller, so we only need to connect them via CAN Transceiver.We use this module for connecting the Arduino UNO R3 because it doesn’t have the built-in CAN Controller. This module connects with the Arduino Uni via SPI connection.Name of the components: CAN Controller: MCP2515 CAN Transceiver: TJA1050Design my own STM32 CAN NodeIf we use a separate CAN Transceiver with the STM32 board. The complexity of wiring become bigger when we have lots of nodes to connect to the bus. To solve this problem, I decided to make a custom PCB board which have a CAN Transceiver lies on it.ComponentsMy custom CAN Node includes: Microcontroller STM32F103C8T6 CAN Transceiver TJA1050 I2C Connector SPI Connector 2x CAN Connector Headers for GPIO Boot configuration selector Connector for the thyristor control boardConnection between boardsWith 2x CAN Connector for each board, we can set up the boards connected in 2 ways: Connection in series Connection in parallel A task for the future: we design this Connection Separator board.Access the fileYou can access the repository for the designed file HERETo design this board, I used Altium Designer program. You have to buy a license or use crack version to use it. I will consider to use KiCAD in the future, because it’s a free and open source program." }, { "title": "How to type Math Expression with MathJax", "url": "/posts/how-to-type-math-expression-with-mathjax/", "categories": "Blogging, Tutorial", "tags": "mathjax, latex, math expression", "date": "2022-07-09 11:50:00 +0300", "snippet": "This post is to show how to write math expression by using MathJax syntax , you can also use it as an example of writing. Now, let’s start looking at MathJax and expressions.What is MathJax?MathJax is a javascript display engine for rendering TEX or MathML-coded mathematics in browsers without requiring font installation or browser plug-ins. Any modern browser with javascript enabled will be MathJax-ready.Some basic syntaxTo type a math expression, surround the expression like below:\\[\\text{\\$expression\\$}\\]The ~ acts as a space in Mathjax expression.Surround the expression by two $ will make the expression center:\\[x~y\\]$$x~y$$ExamplesSum\\[\\sum_{i=0}^{n^3} i^3=\\frac{n(n+1)}{2}\\]$$\\sum_{i=0}^{n^3} i^3=\\frac{n(n+1)}{2}$$Alpha symbol\\[\\alpha^2+\\beta^2=\\gamma^2\\]$$\\alpha^2+\\beta^2=\\gamma^2$$\\[\\Gamma^2+\\Omega^2 = \\Delta^2\\]$$\\Gamma^2+\\Omega^2 = \\Delta^2$$Logarit\\[x_3^5 = log_3(34)\\]$$x_3^5 = log_3(34)$$Small ()\\[\\left( expression \\right)\\]$$\\left( expression \\right)$$Square root\\[\\left(\\frac{\\sqrt{xyz}}{b} = \\sqrt{a}\\right)\\]$$\\left(\\frac{\\sqrt{xyz}}{b} = \\sqrt{a}\\right) $$Big ()\\[\\biggl( ~ \\bigr) ~ \\biggr)\\]$$\\biggl( ~ \\bigr) ~ \\biggr)$$\\[\\bigcup \\bigcap \\int_x^3 \\iiiint \\idotsint\\]$$\\bigcup \\bigcap \\int_x^3 \\iiiint \\idotsint$$Fraction\\[\\cfrac{s}{a}\\]$$\\cfrac{s}{a}$$\\[\\sqrt[3]{x^3} = |x|\\]$$\\sqrt[3]{x^3} = |x|$$Limit\\[\\lim_{x \\to 0}{(x+4)}\\]$$\\lim_{x \\to 0}{(x+4)}$$Trigonometry\\[\\sin^2 \\theta + \\cos^2(\\theta) = 1\\]$$\\sin^2 \\theta + \\cos^2(\\theta) = 1$$Less, equal, greater\\[2 \\lt 3;~ 3 \\leqslant 3; ~ 3 \\neq 2\\]$$2 \\lt 3;~ 3 \\leqslant 3; ~ 3 \\neq 2$$\\[-b \\pm \\sqrt{b^2 - 4ac} \\over 2a\\]$$-b \\pm \\sqrt{b^2 - 4ac} \\over 2a $$Times\\[x \\times y\\]$$x \\times y $$\\[x \\to y; x \\rightarrow y; x \\leftarrow y; x \\Leftarrow y; x \\mapsto y; x \\land y ; x \\lor y\\]$$x \\to y; x \\rightarrow y; x \\leftarrow y; x \\Leftarrow y; x \\mapsto y; x \\land y ; x \\lor y$$ \\[x \\star y; x \\ast y; x \\oplus y; x \\circ y; x \\approx y; x \\sim y ; x \\forall y; x \\top y;\\]$$x \\star y; x \\ast y; x \\oplus y; x \\circ y; x \\approx y; x \\sim y ; x \\forall y; x \\top y; $$Infinity\\[\\infty\\]$$\\infty$$Derivative\\[\\partial x \\over \\partial y\\]$$\\partial x \\over \\partial y$$ \\[a \\equiv c \\pmod b\\]$$a \\equiv c \\pmod b $$\\[a_1 + \\ldots \\cdots a_n\\]$$a_1 + \\ldots \\cdots a_n$$\\[cos\\phi ~ cos\\epsilon ~\\]$$cos\\phi ~ cos\\epsilon ~ $$\\quadInstead of using ~~~, we can use \\quad.\\[a \\quad b\\]$$a \\quad b $$Pure text\\[\\text{hihihi}\\]$$\\text{hihihi}$$Widehat\\[\\widehat{xy}\\]$$\\widehat{xy}$$Vector\\[\\overrightarrow{v} + \\overrightarrow{w} = 1\\]$$\\overrightarrow{v} + \\overrightarrow{w} = 1$$Differential equation\\[\\dot x + \\ddot x = 0\\]$$\\dot x + \\ddot x = 0$$\\[\\{x\\}\\]$$\\{x\\}$$" }, { "title": "Spiderbot", "url": "/posts/ohstem-spiderbot/", "categories": "Projects, Ohstem", "tags": "spiderbot", "date": "2020-11-02 01:26:00 +0300", "snippet": " This page is still in process of building." }, { "title": "Automatic Hand Washing Machine", "url": "/posts/automatic-hand-washing-machine/", "categories": "Projects, High School", "tags": "automatic machine, hand washing", "date": "2020-05-09 01:26:00 +0300", "snippet": " This page is still in process of building." }, { "title": "LED Board for Camping Decoration", "url": "/posts/led-board/", "categories": "Projects, High School", "tags": "led board, decoration", "date": "2019-12-22 01:26:00 +0300", "snippet": " This page is still in process of building." }, { "title": "Virtual Assistance for Visually Impaired People", "url": "/posts/virtual-assistance/", "categories": "Projects, High School", "tags": "virtual assistance, visually impaired people", "date": "2019-08-10 01:26:00 +0300", "snippet": " This page is still in process of building." }, { "title": "Line Follower Robot", "url": "/posts/line-follower-robot/", "categories": "Projects, High School", "tags": "robot, line-follower", "date": "2019-06-29 01:26:00 +0300", "snippet": " This page is still in process of building." }, { "title": "Wireless Lamp Controlling via Wifi", "url": "/posts/wireless-lamp-control/", "categories": "Projects, High School", "tags": "wifi, wireless", "date": "2019-05-14 01:26:00 +0300", "snippet": " This page is still in process of building." }, { "title": "Automatic Watering System", "url": "/posts/automatic-watering-system/", "categories": "Projects, High School", "tags": "automatic watering", "date": "2019-03-23 00:00:00 +0300", "snippet": " This page is still in process of building." }, { "title": "Saigon Tech's approach to make a Self Balancing Robot", "url": "/posts/balancing-robot-saigontech/", "categories": "Projects, Ohstem", "tags": "balancing robot", "date": "2019-01-30 01:26:00 +0300", "snippet": " This page is still in process of building. gitGraph: commit commit branch develop commit commit commit checkout main commit commit" } ]
